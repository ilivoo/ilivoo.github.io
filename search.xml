<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[hexo 使用教程]]></title>
    <url>%2F2018%2F04%2F25%2Fhexo%2F</url>
    <content type="text"><![CDATA[###常见问题 分类和标签统计错误1234cd $HEXO_HOMErm db.jsonhexo cleanhexo generate]]></content>
      <categories>
        <category>hexo</category>
      </categories>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python 正则表达式]]></title>
    <url>%2F2018%2F04%2F25%2Fpython-re%2F</url>
    <content type="text"><![CDATA[定义 正则表达式是一种用来匹配字符串的强有力的武器。它的设计思想是用一种描述性的语言来给字符串定义一个规则，凡是符合规则的字符串，我们就认为它“匹配”了，否则，该字符串就是不合法的。 正则表达式的强大之处在于引入特殊字符来定义字符集、字符集位置、匹配子组、重复模式和扩展表示法。 字符集定义: 符号 描述 正则表达式 匹配案例 literal 匹配字符串的字面值 foo foo re1&#124;re2 匹配正则表达式re1或者re2 foo&#124;bar foo或者bar . 匹配任何字符(除了\n之外) b.b bab […] 匹配来自字符集的任意单个字符 [aeiou] a [^…] 匹配非来自字符集的任何单个字符 [^aeiou] 0 [x-ym-n] 匹配任意来自x~y和m~n范围内的单个字符 [A-Za-z] b \d 匹配任何十进制数字，与[0-9]相同(与\D相反) data\d.txt data1.txt \w 匹配字母数字数字字符,与[A-Za-z0-9]相同(与\w相反) data\w.txt dataa.txt \s 匹配任何空格字符, 与[\n\t\r\v\f]相同(与\S相反) of\sthe of the \x 对特殊字符进行转移 \. . 字符集位置： 符号 描述 正则表达式 匹配 ^ 匹配字符串起始位置 ^Dear Dear $ 匹配字符串终止位置 /bin/*sh$ /bin/bash \A(\Z) 匹配字符串起始(结束)位置 \ADear Dear \b 匹配任何单词边界(与\S相反) \bthe\b the 重复模式： 符号 描述 正则表达式 匹配 * 匹配０次或者多次 [A-Za-z0-9]* abcde + 匹配１次或者多次 [a-z]+.com baidu.com ? 匹配０次或者多次 goo? go {N} 精确匹配Ｎ次 [0-9]3 333 {M,N} 匹配M~N次 [0-9]{5,9} 123456 (*&#124;+&#124;?&#124;{}) 匹配上面重复出现的非贪婪版本 .*?[a-z] abcc 匹配子组： 符号 描述 正则表达式 匹配 (…) 匹配封闭的正则表达式， 然后另存为子组 ([0-9]{3}-)?[0-9]{7-8} 020-888888 \N 配皮上面已经保存的分组 ([0-9]{3})-(\d{7-8}) post is \1 020-12345678 post is 020 扩展表示法： 符号 描述 正则表达式 匹配 贪婪模式正则表达式的默认为贪婪模式，表示竟可能多的匹配， 非贪婪是如果后面正则表达式能够匹配则尽可能少的匹配， 给后面表达式匹配的机会， 如：1234&gt;&gt;&gt; re.match(r&apos;^(\d+)(0*)$&apos;, &apos;102300&apos;).groups() #贪婪(&apos;102300&apos;, &apos;&apos;)&gt;&gt;&gt; re.match(r&apos;^(\d+?)(0*)$&apos;, &apos;102300&apos;).groups() #非贪婪(&apos;1023&apos;, &apos;00&apos;) re 模块123456789101112131415161718192021基础方法compile(pattern, flags = 0) 用任何可选的标记来编译正则表达式，然后返回正则表达式对象match(pattern, string, flags = 0) 尝试使用带可选标记的正则表达式的模式来匹配字符串，如果匹配成功返回匹配对象，否则返回Nonesearch(patter, string, flags = 0) 使用可选的标记搜索字符串中第一次出现正则表达式模式，如果匹配成功返回匹配对象，否则返回None，search是逐个逐个字符的往下匹配findall/finditer(pattern, string[,flags]) 查找字符串中所有(非重复)出现的正则表达式模式，并返回匹配列表split(pattern, string, max = 0) 使用正则表达式分割模式分割字符串，并返回最大max次操作的列表sub(pattern, repl, string, count = 0) 使用repl替换正则表达式的模式在字符串中出现的位置，除非定义count，否则替换所有的位置purge() 清楚隐式编译的正则表达式模式标记re.I | re.IGNORECASE 不区分大小写匹配re.L | re.Locale 根据所使用的本地语言环境通过\w、\W、\b、\B、\s、\S实现匹配re.M | re.MULTILINE ^和$分别匹配目标字符串中行的起始和结束，而不是严格匹配整个字符串本身的起始和结尾re.S | re.DOTALL .号可以匹配所有的字符，包括\nre.X | re.VERBOSE 所有的空格加上#都会被忽略re.T | re.TEMPLATE ...匹配对象的方法group(num = 0) 返回整个匹配对象或者编号为num的特定子组groups(default = None) 返回包含所有匹配子组的元组groupdict(defalt = None) 返回包含所有匹配子组的字典，子组名称作为键]]></content>
      <categories>
        <category>python</category>
        <category>正则表达式</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python 帮助命令]]></title>
    <url>%2F2018%2F04%2F25%2Fpython-help%2F</url>
    <content type="text"><![CDATA[获取内建信息123dir() 打印当前scopedir(__builtins__) 打印内建scopedir(object) 打印对象scope 获取帮助1help(object) 获取类继承层次1Class.mro() 此方法是type中的方法， 每个Class都是type的实例 获取所有的模块1help('modules') 判断对象类型123456789&gt;&gt;&gt; import types&gt;&gt;&gt; type('abc')==types.StringTypeTrue&gt;&gt;&gt; type(u'abc')==types.UnicodeTypeTrue&gt;&gt;&gt; type([])==types.ListTypeTrue&gt;&gt;&gt; type(str)==types.TypeTypeTrue 获取对象中的常量1234567891011121314151617181920212223242526272829303132import typesbase_type = (types.BooleanType, types.FloatType, types.IntType, types.LongType, types.NoneType,types.StringType, types.TupleType, types.ListType, types.DictType, types.ComplexType)def dir_ck(obj): _constant = &#123;&#125; for key, value in obj.__dict__.iteritems(): if type(value) in base_type: _constant[key] = value print sorted(_constant.keys())def dir_ok(obj): _object = &#123;&#125; for key, value in obj.__dict__.iteritems(): if type(value) not in base_type: _object[key] = value print sorted(_object.keys())def dir_c(obj): _constant = &#123;&#125; for key, value in obj.__dict__.iteritems(): if type(value) in base_type: _constant[key] = value for key in sorted(_constant.keys()): print key + "\t = \t" + _constant.get(key)def dir_o(obj): _object = &#123;&#125; for key, value in obj.__dict__.iteritems(): if type(value) not in base_type: _object[key] = value for key in sorted(_object.keys()): print key + "\t = \t" + str(_object.get(key))]]></content>
      <categories>
        <category>python</category>
        <category>帮助</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
</search>
